<script>
  function normalizeToken(s) {
    return (s || "")
      .toLowerCase()
      .replace(/å/g, "a").replace(/ä/g, "a").replace(/ö/g, "o")
      .replace(/[^a-z0-9]+/g, ""); // poista välit ja erikoismerkit
  }

  function parseViscosity(vis) {
    const m = (vis || "").toUpperCase().match(/^(\d+)W-(\d+)$/);
    if (!m) return null;
    return { w: Number(m[1]), hot: Number(m[2]) };
  }

  function splitQueryTokens(text) {
    // esim "VW 504 507 ACEA C3" -> ["vw","504","507","acea","c3","vw504","vw507","504507"]
    const raw = (text || "").toLowerCase();
    const parts = raw.split(/\s+/).filter(Boolean);
    const basic = parts.map(normalizeToken).filter(Boolean);

    // lisää yhdistelmät, jotka ovat käytännössä hyödyllisiä
    const combos = [];
    if (basic.includes("vw") && basic.includes("504") && basic.includes("507")) combos.push("vw504", "vw507", "504507");
    if (basic.includes("acea") && basic.includes("c3")) combos.push("c3");
    return Array.from(new Set([...basic, ...combos]));
  }

  function scoreProduct(product, qTokens) {
    if (!qTokens.length) return 0;

    const tokenSet = new Set((product.tokens || []).map(normalizeToken));
    let score = 0;

    for (const t of qTokens) {
      if (tokenSet.has(t)) score += 10;
      // pieni “contains” jousto (esim. 22951 vs mb22951)
      else {
        for (const pt of tokenSet) {
          if (pt.includes(t) || t.includes(pt)) { score += 3; break; }
        }
      }
    }

    // Pieni bonus, jos query sisältää ACEA/API ja tuote sisältää saman
    const acea = normalizeToken(product.acea || "");
    const api  = normalizeToken(product.api || "");
    if (qTokens.includes("c3") && acea.includes("c3")) score += 8;
    if (qTokens.includes("c2") && acea.includes("c2")) score += 8;
    if (qTokens.includes("sp") && api.includes("sp")) score += 6;

    return score;
  }

  async function main() {
    const params = new URLSearchParams(location.search);
    const vis = params.get("vis") || "";
    const lua = params.get("lua") || "";
    const merkki = params.get("rek") || "";
    const q = `${lua} ${merkki}`.trim();

    const v = parseViscosity(vis);
    if (!v) {
      document.getElementById("results").innerHTML =
        "<p>Viskositeetti on virheellinen. Käytä muotoa 0W-20, 5W-30, 5W-40 jne.</p>";
      return;
    }

    const res = await fetch("data/fanfaro_search_index.json");
    const products = await res.json();

    // 1) Viskositeetti ensin
    const candidates = products.filter(p => Number(p.sae_w) === v.w && Number(p.sae_hot) === v.hot);

    // 2) Vapaa teksti pisteytyksellä
    const qTokens = splitQueryTokens(q);
    const ranked = candidates
      .map(p => ({ p, score: scoreProduct(p, qTokens) }))
      .sort((a, b) => b.score - a.score);

    // 3) Näytä top 3
    const top = ranked.slice(0, 3).filter(x => x.score > 0);
    const fallback = ranked.slice(0, 3); // jos query tyhjä/ei osumia

    const finalList = top.length ? top : fallback;

    const html = finalList.map(x => `
      <div style="padding:12px;border:1px solid #e5e7eb;border-radius:12px;margin-bottom:10px;">
        <div style="font-weight:800;color:#111827;">
          ${x.p.brand} ${x.p.code} – ${x.p.name}
        </div>
        <div style="color:#374151;margin-top:4px;">
          <strong>${x.p.sae}</strong> · ${x.p.acea || ""} ${x.p.api ? "· " + x.p.api : ""}
        </div>
        <div style="color:#6b7280;margin-top:6px;font-size:12px;">
          OEM: ${x.p.oem || "-"}<br/>
          SAPS: ${x.p.saps || "-"} · DPF: ${x.p.dpf || "-"}<br/>
          Profile: ${x.p.technical_profile_id || "-"} · Score: ${x.score}
        </div>
      </div>
    `).join("");

    document.getElementById("results").innerHTML = html || "<p>Ei tuloksia.</p>";
  }

  main();
</script>
